#include <iostream>

using namespace std;

// N = 1 (1개)
// -> 세로1
//
// N = 2 (2개)
// -> 세로1 + 세로1
// -> 가로2
//
// N = 3 (3개)
// -> 세로1 + 세로1 + 세로1
// -> 가로2 + 세로1
// -> 세로1 + 가로2
//
// N = 4 (5개)
// -> 세로1 + 세로1 + 세로1 + 세로1
// -> 가로2 + 가로2
// -> 세로1 + 가로2 + 세로1
// -> 세로1 + 세로1 + 가로2
// -> 가로2 + 세로1 + 세로1

// 가능한 모든 경우를 찾아야 하지만
// 이전의 경우에 이번에 새로운 경우를 추가하면 됨 -> 중복 부분 문제
// 이전의 경우로 이번의 경우의 수를 정확히 만들어낼 수 있음 -> 최적 부분 구조

// N번째 칸에서 모든 방법의 수
inline int dp[1001];

inline void solve()
{
	int n;
	cin >> n;

	// N이 1일때랑 N이 2일때까지가 베이스 케이스임
	// -> 새롭게 놓는 경우가 여기까지 있음

	dp[1] = 1;
	dp[2] = 2;

	// 점화식:
	// dp[i] = dp[i - 1] + dp[i - 2]

	for (int ii = 3; ii <= n; ++ii)
	{
		dp[ii] = (dp[ii - 1] + dp[ii - 2]) % 10007;
	}

	cout << dp[n] << '\n';
}
