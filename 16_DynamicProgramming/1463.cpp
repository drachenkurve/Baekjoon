#include <iostream>

using namespace std;

// X = 1
//
// X = 2
// -> -1
// -> /2
//
// X = 3
// -> -1, -1
// -> -1, /2
// -> /3
//
// X = 4
// -> -1, -1, -1
// -> -1, -1, /2
// -> -1, /3
// -> /2, -1
//
// X = 5
// -> -1, -1, -1, -1
// -> -1, /2, -1
// -> -1, /2, /2
// -> -1, -1, /3
//
// X = 6
// -> -1, -1, -1, -1, -1
// -> -1, -1, /2, -1
// -> -1, -1, /2, /2
// -> -1, -1, -1, /3
// -> /2, -1, -1
// -> /2, /3
// -> /3, -1
// -> /3, /2
//
// X의 방법의 수는 X-1의 방법의 수에 이번에 가능한 방법의 수를 다시 더한 것 -> 중복 부분 문제
// -> 이전의 해가 현재의 해에 포함됨 -> 최적 부분 구조

// 숫자 X에서 가능한 방법의 최솟값
inline int dp[1000001];

inline void solve()
{
	int n;
	cin >> n;

	dp[1] = 0;
	dp[2] = 1;
	dp[3] = 1;

	// 4부터는 그냥 이전 결과의 합 -> 이미 2랑 3으로 나누는 부분이 처리됨

	// 점화식:
	// if (i > 0) dp[i] = dp[i - 1] + 1,
	// if (i % 2 == 0) dp[i] = min(dp[i], dp[i / 2] + 1],
	// if (i % 3 == 0) dp[i] = min(dp[i], dp[i / 3] + 1],

	for (int ii = 4; ii <= n; ++ii)
	{
		dp[ii] = dp[ii - 1] + 1;

		if (ii % 2 == 0)
		{
			dp[ii] = min(dp[ii], dp[ii / 2] + 1);
		}

		if (ii % 3 == 0)
		{
			dp[ii] = min(dp[ii], dp[ii / 3] + 1);
		}
	}

	cout << dp[n] << '\n';
}
