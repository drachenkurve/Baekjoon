#include <iostream>

using namespace std;

// 1턴
// -> 10을 밟는다 -> 10
// -> 20을 밟는다 -> 20
//
// 2턴
// -> 10을 밟는다 -> 20을 밟는다 -> 30
// -> 10을 밟는다 -> 30을 밟는다 -> 40
// -> 20을 밟는다 -> 30을 밟는다 -> 50
// -> 20을 밟는다 -> 40을 밟는다 -> 60
//
// 3턴
// -> 10을 밟는다 -> 20을 밟는다 -> 30을 밟는다 -> X
// -> 10을 밟는다 -> 20을 밟는다 -> 40을 밟는다 -> 70
// -> 10을 밟는다 -> 30을 밟는다 -> 40을 밟는다 -> 80
// -> 10을 밟는다 -> 30을 밟는다 -> 50을 밟는다 -> 80
// -> 20을 밟는다 -> 30을 밟는다 -> 40을 밟는다 -> X
// -> 20을 밟는다 -> 30을 밟는다 -> 50을 밟는다 -> 100
// -> 20을 밟는다 -> 40을 밟는다 -> 50을 밟는다 -> 110
// -> 20을 밟는다 -> 40을 밟는다 -> 60을 밟는다 -> 120
//
// 턴으로는 세는게 이상해짐
// 경우의 수가 2^N -> N이 최대 10000이므로 전부 찾으면 1억은 일단 넘음
// 어떤 계단에서서 최대 점수로 가야 함

// [i - 1] 번째 연속으로 밟을 때 최대 점수
// 마지막은 무조건 밟으니까 가능
inline int dp[301][2];

// N번째 계단의 점수
inline int score[301];

inline void solve()
{
	int n;
	cin >> n;

	for (int nn = 1; nn <= n; ++nn)
	{
		cin >> score[nn];
	}

	// 1번째 계단
	// 1전진 -> 10
	// 2전진 -> 0 (불가능)
	//
	// 2번째 계단
	// 1전진 -> 20
	// 2전진 -> 30
	//
	// N번째 계단
	// 이번에 1전진 -> 2번째 전의 1연속 또는 2연속 중 최댓값
	// 이번에 2전진 -> 1번째 전의 1연속

	dp[1][0] = score[1];
	dp[1][1] = 0;

	dp[2][0] = score[2];
	dp[2][1] = score[1] + score[2];

	// 점화식:
	// dp[i][0] = score[i] + max(dp[i - 2][0], dp[i - 2][1])
	// dp[i][1] = score[i] + dp[i - 1][1]

	for (int ii = 3; ii <= n; ++ii)
	{
		dp[ii][0] = score[ii] + max(dp[ii - 2][0], dp[ii - 2][1]);
		dp[ii][1] = score[ii] + dp[ii - 1][0];
	}

	cout << max(dp[n][0], dp[n][1]) << '\n';
}
